### 目录：
- 1. 项目背景及目的
- 2. 数据探索(EDA)
- 3. 数据清洗
- 4. 建模与模型评价分析
- 5. 总结

### 1. 项目背景及目的
#### 1.1 背景
在kaggle上看到一个关于预测流失用户的项目：
某银行信用卡业务的客户流失问题日益显著，其银行经理为此很困扰。他们希望有人能帮助预测哪部分客户即将流失，从而能提前采取有效措施挽回这部分客户，让客户留存下来。
现有该业务的一个数据集，包含 10,000 多名客户信息，字段如下：年龄、薪水、婚姻状况、信用卡额度、信用卡类型等等，共计 18 个字段。
数据集里只有 16.7% 的客户是流失客户，存在类别不均衡问题。
>
[数据获取地址](https://www.kaggle.com/sakshigoyal7/credit-card-customers/notebooks?datasetId=982921&sortBy=voteCount)
>
#### 1.2 目的
- 建模预测即将流失用户
- 找出关键影响流失的因素，为银行经理提供相关建议
>
### 2. 数据探索(EDA)
分类别型和数值型特征两大块做初步的了解,先导入相关包与读入数据：
```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# @Author  : Hush
# @Software: PyCharm

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['font.sans-serif'] = 'SimHei'
plt.rcParams['axes.unicode_minus'] = False
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler  # 标准化
from sklearn.preprocessing import LabelEncoder  # 字符串编码
from imblearn.over_sampling import SMOTE  # 样本不均衡，用上采样


bank_churners_data = pd.read_csv(r'C:\Users\Administrator\Desktop\credit card customers\BankChurners.csv')
pd.set_option('display.max_columns', None)  # 显示所有列
pd.set_option('display.max_rows', None)  # 显示所有行
print(bank_churners_data.sample(5))
print(bank_churners_data.info())
print(bank_churners_data.describe(include='O'))
```

可以看到，数据集里一共有 10,127 行数据，23 个特征，缺失值以'unknown'字符串存在于数据集，数据类型有数值整型、数值浮点型、字符串。最后两列的数据、客户账号对数据分析没有实际作用，需要删除。
```
bank_churners_data.drop(columns=['CLIENTNUM',
                                 'Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_1',
                                 'Naive_Bayes_Classifier_Attrition_Flag_Card_Category_Contacts_Count_12_mon_Dependent_count_Education_Level_Months_Inactive_12_mon_2'],
                        inplace=True)
# print(bank_churners_data.info())
print('——————客户流失情况：——————')
print(bank_churners_data['Attrition_Flag'].value_counts())
churn = bank_churners_data['Attrition_Flag'].value_counts()
plt.pie(churn.values, labels=churn.index, autopct='%1.2f%%')
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/92b48c60aa6ac979.png)
流失客户占比不到16.1%，虽然类别失衡还没达到10倍数，但是后面还是要通过 Smote 来改善类别不平衡问题。
下面了解一下各特征对流失的影响：
#### 2.1 类别型特征
##### (2.1.1) 性别对客户留存的影响
```
print('客户性别分布情况：\n', bank_churners_data['Gender'].value_counts(ascending=True))
gen = bank_churners_data['Gender'].value_counts(ascending=True)
plt.figure(figsize=(10, 4))
plt.subplot(121)
plt.pie(gen.values, labels=gen.index, autopct='%1.2f%%')
plt.title('性别占比', fontsize=10)

plt.subplot(122)
sns.countplot(x='Attrition_Flag', data=bank_churners_data, hue='Gender', palette='Set3')
plt.xlabel('客户类型')
plt.ylabel('人数')
plt.title('各类别客户性别人数', fontsize=10)

plt.suptitle('性别对客户留存的影响')   # 添加一个总标题，前面的是小标题
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/ef01bfd9164f2bb0.png)
从图看出，女性客户占比较大，占总客户数的53%，比男性多5个百分点。
在留存或流失客户群体中，女性客户数均比男性客户多。

##### (2.1.2) 教育水平对客户留存的影响
降序排位，从大到小，给后面画图提供排序依据
```
plt.figure(figsize=(10, 5))
plt.subplot(121)
edu = bank_churners_data['Education_Level'].value_counts(ascending=False)
edu_percent = bank_churners_data['Education_Level'].value_counts(normalize=True, ascending=False)
print(edu)
print(edu_percent)
sns.countplot(x='Education_Level', data=bank_churners_data, order=edu.index, palette='Set3')
# plt.text(x=[1,2,3,4,5,6,7] , y=[1,2,3,4,5,6,7], s=edu_percent.values)  # 暂时不会加数据标签
plt.xlabel('教育水平')
plt.ylabel('人数')
plt.title('教育水平分布', fontsize=10)
plt.xticks(rotation=-25)  # 调整横坐标标签的倾斜程度，根据实际情况调整角度以显示清楚

plt.subplot(122)
sns.countplot(x='Education_Level', data=bank_churners_data, hue='Attrition_Flag', order=edu.index, palette='Set3')
plt.xlabel('教育水平')
plt.ylabel('人数')
plt.title('各类别客户教育水平', fontsize=10)
plt.xticks(rotation=-25)

plt.suptitle('教育水平对客户留存的影响')   # 添加一个总标题，前面的是小标题
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/d857423f6f832f08.png)
Graduate和High school这两部分占到总体的50%，有15%学历未知，15%没有接受过教育。其中，至少保证有70%的人都接受过教育。
分类别来看教育水平情况，也没有很明显的信息说明哪个阶段的教育水平影响了客户的留存。

##### (2.1.3) 婚姻状况对客户留存的影响
```
plt.figure(figsize=(10, 5))
plt.subplot(121)
edu = bank_churners_data['Marital_Status'].value_counts(ascending=False)
edu_percent = bank_churners_data['Marital_Status'].value_counts(normalize=True, ascending=False)
print(edu)
print(edu_percent)
sns.countplot(x='Marital_Status', data=bank_churners_data, order=edu.index, palette='Set3')
# plt.text(x=[1,2,3,4,5,6,7] , y=[1,2,3,4,5,6,7], s=edu_percent.values)  # 暂时不会加数据标签
plt.xlabel('婚姻状况')
plt.ylabel('人数')
plt.title('婚姻状况分布', fontsize=10)
# plt.xticks(rotation=-25)

plt.subplot(122)
sns.countplot(x='Marital_Status', data=bank_churners_data, hue='Attrition_Flag', order=edu.index, palette='Set3')
plt.xlabel('婚姻状况')
plt.ylabel('人数')
plt.title('各类别客户婚姻状况', fontsize=10)
# plt.xticks(rotation=-25)

plt.suptitle('婚姻状况对客户留存的影响')   # 添加一个总标题，前面的是小标题
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/0e297a6def18c459.png)
已经结婚的客户占46%,接近一半，单身客户占39%,有7%未知,其余7%是已经离婚的。
在类别对比里，看到婚姻状况没有很明显影响客户的留存。

##### (2.1.4) 收入水平对客户留存的影响
```
plt.figure(figsize=(10, 5))
plt.subplot(121)
edu = bank_churners_data['Income_Category'].value_counts(ascending=False)
edu_percent = bank_churners_data['Income_Category'].value_counts(normalize=True, ascending=False)
print(edu)
print(edu_percent)
sns.countplot(x='Income_Category', data=bank_churners_data, order=edu.index, palette='Set3')
# plt.text(x=[1,2,3,4,5,6,7] , y=[1,2,3,4,5,6,7], s=edu_percent.values)  # 暂时不会加数据标签
plt.xlabel('收入水平')
plt.ylabel('人数')
plt.title('收入水平情况', fontsize=10)
plt.xticks(rotation=-25)

plt.subplot(122)
sns.countplot(x='Income_Category', data=bank_churners_data, hue='Attrition_Flag', order=edu.index, palette='Set3')
plt.xlabel('收入水平')
plt.ylabel('人数')
plt.title('各类别客户收入水平情况', fontsize=10)
plt.xticks(rotation=-25)

plt.suptitle('收入水平对客户留存的影响')   # 添加一个总标题，前面的是小标题
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/fe3ad982bfd96240.png)
可以看到，收入少于40k的客户占35%，40-60K的占18%，80-120K占15%，60-80K的占14%，120K+的占7%，不知道收入水平的占11%。
分类别来看，收入水平没有很明显地影响客户的留存。

##### (2.1.5) 信用卡级别的对客户留存的影响
```
plt.figure(figsize=(10, 5))
plt.subplot(121)
edu = bank_churners_data['Card_Category'].value_counts(ascending=False)
edu_percent = bank_churners_data['Card_Category'].value_counts(normalize=True, ascending=False)
print(edu)
print(edu_percent)
sns.countplot(x='Card_Category', data=bank_churners_data, order=edu.index, palette='Set3')
# plt.text(x=[1,2,3,4,5,6,7] , y=[1,2,3,4,5,6,7], s=edu_percent.values)  # 暂时不会加数据标签
plt.xlabel('信用卡类型')
plt.ylabel('人数')
plt.title('信用卡类型', fontsize=10)
plt.xticks(rotation=-25)

plt.subplot(122)
sns.countplot(x='Card_Category', data=bank_churners_data, hue='Attrition_Flag', order=edu.index, palette='Set3')
plt.xlabel('信用卡类型')
plt.ylabel('人数')
plt.title('各类别客户信用卡类型', fontsize=10)
plt.xticks(rotation=-25)

plt.suptitle('信用卡类型对客户留存的影响')
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/30aa5c4c83263d40.png)
有93%的客户持有的都是蓝卡，银卡、金卡、铂金卡共占7%。
分类别来看，信用卡类型并没有很明显地影响客户的留存。

#### 2.2 数值型特征
- Customer_Age: the age of Customer
- Dependent_count: Number of dependents
- Months_on_book: Period of relationship with bank
- Total_Relationship_Count: Total no. of products held by the customer
- Months_Inactive_12_mon: No. of months inactive in the last 12 months
- Contacts_Count_12_mon: No. of Contacts in the last 12 months
- Credit_Limit: Credit Limit on the Credit Card
- Total_Revolving_Bal: Total Revolving Balance on the Credit Card
- Avg_Open_To_Buy: Open to Buy Credit Line (Average of last 12 months)
- Total_Amt_Chng_Q4_Q1: Change in Transaction Amount (Q4 over Q1)
- Total_Trans_Amt: Total Transaction Amount (Last 12 months)
- Total_Trans_Ct: Total Transaction Count (Last 12 months)
- Total_Ct_Chng_Q4_Q1: Change in Transaction Count (Q4 over Q1)
- Avg_Utilization_Ratio: Average Card Utilization Ratio
>
##### (2.2.1) 年龄对客户留存的影响
```
print('客户年龄情况：', bank_churners_data['Customer_Age'].describe())
plt.figure(figsize=(12, 4))
plt.subplot(131)  # 现在画第一张
sns.distplot(bank_churners_data['Customer_Age'],
             kde_kws={'label': 'KDE 核密度曲线', 'linestyle': '--'})  # 设置核密度曲线
plt.xlabel('年龄')
plt.title('年龄分布', fontsize=10)

plt.subplot(132)   # 现在画第二张
sns.boxplot(x='Attrition_Flag', y='Customer_Age', data=bank_churners_data,
            width=0.7, palette='Set3')
plt.xlabel('客户类型')
plt.ylabel('年龄')
plt.title('不同类别客户年龄分布(1)', fontsize=10)

plt.subplot(133)   # 现在画第三张
sns.violinplot(x='Attrition_Flag', y='Customer_Age', data=bank_churners_data, palette='Set3')
plt.xlabel('客户类型')
plt.ylabel('年龄')
plt.title('不同类别客户年龄分布(2)', fontsize=10)

plt.suptitle('年龄对客户留存的影响')   # 添加一个总标题，前面的是小标题
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2021/01/82bf7ad390cca0fb.png)
看到，客户的年龄接近正态分布,最小年龄为26，最大年龄为73，平均数和中位数都是46，41-52岁的客户占到总人数的50%；
从箱线图和小提琴图可以看到，流失客户的年龄中位数会比留存客户的大，但总的来看，两者的年龄分布比较接近，差别不大。

##### (2.2.2) 相关联账户数量对客户留存的影响
```
print('相关联账户数量：', bank_churners_data['Dependent_count'].describe())
plt.figure(figsize=(12, 4))
plt.subplot(131)  # 现在画第一张
sns.distplot(bank_churners_data['Dependent_count'], kde=False)
plt.xlabel('相关联账户数')
plt.ylabel('人数')
plt.title('相关联账户数量分布', fontsize=10)

plt.subplot(132)   # 现在画第二张
sns.boxplot(x='Attrition_Flag', y='Dependent_count', data=bank_churners_data,
            width=0.7, palette='Set3')
plt.xlabel('客户类型')
plt.ylabel('相关联账户数')
plt.title('相关联账户数分布(1)', fontsize=10)

plt.subplot(133)   # 现在画第三张
sns.violinplot(x='Attrition_Flag', y='Dependent_count', data=bank_churners_data, palette='Set3')
plt.xlabel('客户类型')
plt.ylabel('相关联账户数')
plt.title('相关联账户数分布(2)', fontsize=10)

plt.suptitle('相关联账户数对客户留存的影响')   # 添加一个总标题，前面的是小标题
plt.show()
```
![](https://imgchr.com/i/slHq0I)
每人平均拥有2-3个相关联账户，中位数是2。有50%的客户拥有相关联账户数在1-3个。
分类别来看，流失用户有50%集中于2-3个相关联的账户(箱线图箱体比较扁)，存在个别异常值。留存用户有50%客户集中于1-3个相关账户。总的来看，看不出相关联账户数对客户留存的影响。

##### (2.2.3) 其余数值型特征对客户流失的影响
看看其余12个数值型特征:
```
other_numerical_fea = ['Months_on_book', 'Total_Relationship_Count', 'Months_Inactive_12_mon', 'Contacts_Count_12_mon',
                 'Credit_Limit', 'Total_Revolving_Bal', 'Avg_Open_To_Buy', 'Total_Amt_Chng_Q4_Q1',
                 'Total_Trans_Amt', 'Total_Trans_Ct', 'Total_Ct_Chng_Q4_Q1', 'Avg_Utilization_Ratio']
# print(len(other_numerical_fea))

for i in other_numerical_fea:
    print('特征%s的分布情况:' % i, bank_churners_data[i].describe())
    plt.figure(figsize=(12, 4))
    plt.subplot(131)
    # 不同值较多的特征才画核密度线：
    if bank_churners_data[i].nunique() > 20:
        sns.distplot(bank_churners_data[i])
    else:
        sns.distplot(bank_churners_data[i], kde=False)

    plt.subplot(132)
    sns.boxplot(x='Attrition_Flag', y=i, data=bank_churners_data,
                width=0.7, palette='Set3')

    plt.subplot(133)
    sns.violinplot(x='Attrition_Flag', y=i, data=bank_churners_data, palette='Set3')

    plt.suptitle('特征%s对客户留存的影响'%i)
    plt.show()
```
![](https://s3.ax1x.com/2021/01/11/s8u0Z4.png)
![](https://s3.ax1x.com/2021/01/11/s8uvwQ.png)
![](https://s3.ax1x.com/2021/01/11/s8KPS0.png)
![](https://s3.ax1x.com/2021/01/11/s8KkOU.png)
![](https://s3.ax1x.com/2021/01/11/s8Kuf1.png)
![](https://s3.ax1x.com/2021/01/11/s8KUfI.png)
![](https://s3.ax1x.com/2021/01/11/s8K06f.png)
![](https://s3.ax1x.com/2021/01/11/s8Kckj.png)
![](https://s3.ax1x.com/2021/01/11/s8K2hn.png)
![](https://s3.ax1x.com/2021/01/11/s8KoBF.png)
![](https://s3.ax1x.com/2021/01/11/s8KT74.png)
![](https://s3.ax1x.com/2021/01/11/s8KO91.png)
在部分特征里，存在较多异常值。
其中，在客户分类看到，两种客户的特征分布存在一定的差异。
这些特征十几个，而且没有太专业的业务了解，暂时都将这些特征保留下来。
```
numerical_fea = ['Customer_Age', 'Dependent_count'] + other_numerical_fea
plt.figure(figsize=(11, 11))
sns.heatmap(bank_churners_data[numerical_fea].corr('pearson'), annot=True, square=True, cmap='RdBu_r',
            vmax=1.0, vmin=-1, linewidths=0.3)
plt.xticks(rotation=-60)
plt.show()
```
从热力图看到，
- Total_Trans_Amt 和 Total_Trans_Ct 的相关性达到 0.81
- Months_on_book 和 Customer_Age 相关性达到 0.79
- Total_Revolving_Bal 和 Avg_Utilization_Ratio相关性为0.62
其余数特征之间没有很明显的线性相关关系。
下面不采用LR。

### 3. 数据清洗
首先，将类别型变量热编码：
```
bank_churners_data['Attrition_Flag'] = bank_churners_data['Attrition_Flag'].replace({'Existing Customer': 0, 'Attrited Customer': 1})
bank_churners_data['Gender'] = bank_churners_data['Gender'].replace({'M': 0, 'F': 1})
dummy_fea = ['Education_Level', 'Marital_Status', 'Income_Category', 'Card_Category']
dummy_df = pd.DataFrame()
# Card_Category
new_dummy = pd.get_dummies(bank_churners_data['Card_Category'], prefix='Card_Category').drop(columns=['Card_Category_Silver'])  # 一定要删除dummy后的其中一列（共线性）
dummy_df = pd.concat([dummy_df, new_dummy], axis=1)
# Education_Level
new_dummy = pd.get_dummies(bank_churners_data['Education_Level'], prefix='Education_Level').drop(columns=['Education_Level_Unknown'])
dummy_df = pd.concat([dummy_df, new_dummy], axis=1)
# Marital_Status
new_dummy = pd.get_dummies(bank_churners_data['Marital_Status'], prefix='Marital_Status').drop(columns=['Marital_Status_Unknown'])
dummy_df = pd.concat([dummy_df, new_dummy], axis=1)
# Income_Category
new_dummy = pd.get_dummies(bank_churners_data['Income_Category'], prefix='Income_Category').drop(columns=['Income_Category_Unknown'])
dummy_df = pd.concat([dummy_df, new_dummy], axis=1)
```
然后，删掉没用的列（已经被get_dummy），重新组合建模数据：
```
new_bank_churners_data = bank_churners_data.drop(columns=dummy_fea)
new_bank_churners_data = pd.concat([new_bank_churners_data, dummy_df], axis=1)
print(new_bank_churners_data.head(5))
print(new_bank_churners_data.shape)
```
现在数据集大小：(10127, 33)
下面先划分训练集测试集、做上采样（不平衡问题），然后做标准化，再进行建模：
```
X = new_bank_churners_data.iloc[:, 1:]
Y = new_bank_churners_data.iloc[:, 0]
print('X:', X.shape)
print('Y:', Y.shape)
x_train, x_test, y_train, y_test = train_test_split(X, Y, train_size=0.75, random_state=123)
print('x_train:', x_train.shape)
print('y_train:', y_train.shape)
print('y_train分布：', Counter(y_train))
# SMOTE上采样
smo = SMOTE()
x_smo, y_smo = smo.fit_sample(x_train, y_train)
print('上采样后（SMOTE）标签分布情况：', Counter(y_smo))
# 标准化操作
scaler = StandardScaler()
scaler.fit(x_smo)
x_smo_scaled = scaler.transform(x_smo)
x_smo_scaled = pd.DataFrame(x_smo_scaled, columns=x_train.columns)
print(x_smo_scaled.head(5))
x_test_scaled = scaler.transform(x_test)
```
```
rf_select = RandomForestClassifier(random_state=666)
rf_select.fit(x_smo_scaled, y_smo)
fea_importance = rf_select.feature_importances_
index_sorted = np.argsort(fea_importance)  # fea_importance从小到大排列，并提取其对应的index(索引)，后面画图用
# print(index_sorted)
# 前25特征
plt.figure(figsize=(7, 6))
bar_position = np.arange(25) + 0.5   # 定义条形位置
plt.barh(bar_position, fea_importance[index_sorted][-25:], align='center')
plt.yticks(bar_position, x_smo_scaled.columns[index_sorted][-25:])  # y轴标签
plt.xlabel("属性重要性")
plt.title("前25个重要特征")
plt.tight_layout()
plt.show()
# 前20特征
plt.figure(figsize=(7, 6))
bar_position = np.arange(20) + 0.5   # 定义条形位置
plt.barh(bar_position, fea_importance[index_sorted][-20:], align='center')
plt.yticks(bar_position, x_smo_scaled.columns[index_sorted][-20:])  # y轴标签
plt.xlabel("属性重要性")
plt.title("前20个重要特征")
# plt.tight_layout()
plt.show()
print('特征重要性：', fea_importance[index_sorted][-4:])
print('前20的特征：', x_smo_scaled.columns[index_sorted][-20:])
```
![](https://ftp.bmp.ovh/imgs/2021/01/a4dfbd1863da1e74.png)
![](https://ftp.bmp.ovh/imgs/2021/01/4521c65c3abc2fe1.png)
可以看到，前4个特征有较明显的作用,分别是：
Total_Trans_Ct(0.20) > Total_Trans_Amt(0.18) > Total_Revolving_Bal(0.10) > Total_Ct_Chng_Q4_Q1(0.09)
其余特征的作用相对较小。
下一步建模，采用前20个特征，其余特征暂时撇除。

###  4. 建模与模型评价分析
可以看到，前4个特征有较明显的作用,分别是Total_Trans_Ct(0.20)>Total_Trans_Amt(0.18)>Total_Revolving_Bal(0.10)>Total_Ct_Chng_Q4_Q1(0.09)
其余特征的作用相对较小。下一步建模，采用前20个特征，其余特征暂时撇除。
x_20_train = x_smo_scaled[col_20]
x_20_test = x_test_scaled[col_20]
# 建模
# 采用随机森林、决策树、KNN、SVM、
#### (1) KNN
```
cv_Fold = StratifiedKFold(n_splits=10, shuffle=True, random_state=321)
k_range = range(1, 31)
cv_scores = []
for n in k_range:
    knn = KNeighborsClassifier(n_neighbors=n)
    scores = cross_val_score(knn, x_20_train, y_smo, cv=cv_Fold, scoring='f1')
    cv_scores.append(scores.mean())
plt.plot(k_range,cv_scores)
plt.xlabel('K')
plt.ylabel('f1')
plt.show()
```
当n=6时，f1较高，取n=6
```
best_knn = KNeighborsClassifier(n_neighbors=6)
best_knn.fit(x_20_train, y_smo)
print('KNN训练集分数：', best_knn.score(x_20_train, y_smo))
print('KNN测试集分数：', best_knn.score(x_20_test, y_test))
```

用xgboost尝试












###  5. 总结

做PCA效果不佳，暂时不用


https://cj.sina.com.cn/articles/view/2095452301/7ce6108d01900afck

