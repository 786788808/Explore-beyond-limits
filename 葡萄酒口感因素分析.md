#### 目录
- 一. 研究背景与目的
- 二. 数据探索
- 三. 数据清洗
- 四. 建模分析

### 一. 研究背景与目的：  
在UCI数据集里找到一个关于品酒的数据集，数据行包含各种酿酒成分以及专家对该酒的评分。   
数据下载地址：http://www3.dsi.uminho.pt/pcortez/wine/   
数据集包含白葡萄酒数据集，本篇选择白葡萄酒数据集：包含4898行，12列数据。都是数值型数据，很适合做回归分析。        
探寻影响白葡萄酒质量因素，哪些因素的影响比较大，哪些因素的影响比较小，是否存在可忽略的因素。是否可以给这些因素排优先级，给酿酒师提供一些建议。    

### 二. 数据探索：  
```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
plt.rcParams["font.sans-serif"] = ["SimHei"]  # 正常显示中文标签
plt.rcParams["axes.unicode_minus"] = False   # 正常显示负号
plt.style.use('ggplot')
import seaborn as sns
pd.set_option('display.max_columns', None)

wine_data = pd.read_csv(r'E:\……\data\winequality\winequality-white.csv', sep=';')
print((wine_data.head(5)))
print(wine_data.info())
print(wine_data.quality.unique())
print('重复值个数:', wine_data.duplicated().sum())  # 由多位品酒师评分，重复行不用管
print(wine_data.describe())
print(wine_data.quality.value_counts())
col = wine_data.columns.to_list()
# 箱线图
plt.figure(figsize=(11, 7))
for i in range(12):
    plt.subplot(2, 6, i+1)
    sns.boxplot(col[i], data=wine_data, orient='v', width=0.4, color='#0099CC')
    plt.ylabel(col[i])
plt.suptitle('各特征分布箱线图')
# 微调图的细节，left整体距离左边的距离，wspace子图之间的距离，top整体距离顶部的距离
plt.subplots_adjust(left=0.1, wspace=0.7, top=0.9)
plt.show()
# 直方图
plt.figure(figsize=(11, 7))
for i in range(12):
    plt.subplot(3, 4, i+1)
    plt.hist(col[i], data=wine_data, bins=110, color='#0099CC')
    plt.xlabel(col[i])
    plt.ylabel('Frequency')
plt.suptitle('各特征分布直方图')
# 微调图的细节，left整体距离左边的距离，wspace子图之间的距离，top整体距离顶部的距离
plt.subplots_adjust(left=0.1, wspace=0.7, hspace=0.5, top=0.9)
plt.show()
print('——————————偏度:——————————\n', wine_data.skew().sort_values(ascending=False))  # 偏度
print('=='*30)
print('——————————峰度：——————————\n', wine_data.kurt().sort_values(ascending=False))  # 峰度
```
#### (2.1) 自变量与因变量
自变量：'fixed acidity'非挥发性酸, 'volatile acidity'挥发性酸度, 'citric acid'柠檬酸, 'residual sugar'残糖, 'chlorides'氯化物, 'free sulfur dioxide'游离二氧化硫, 'total sulfur dioxide'总二氧化硫, 'density'密度,'pH'酸碱性, 'sulphates'硫酸盐, 'alcohol'酒精    
因变量：'quality' 质量分  
下面分别是箱线图与直方图：  
![](https://ftp.bmp.ovh/imgs/2020/12/615eeb1be28e8fe4.png)  
![](https://ftp.bmp.ovh/imgs/2020/12/8782f072a765e88a.png)  
![](https://ftp.bmp.ovh/imgs/2020/12/8a4bd52f95233d85.png)
![](https://ftp.bmp.ovh/imgs/2020/12/98f2943617506238.png)  
![](https://ftp.bmp.ovh/imgs/2020/12/297af7b553e05754.png)  
可以看到：      
(1) 各特征值的范围差别大，有的特征值范围在\[0,0.35]，有的特征值范围在\[0,500]。回归算法里用到MSE作为评判建模效果，下面需要将各特征标准化处理，消除量纲的影响。      
(2) 从箱线图看到，部分变量存在较多异常值。但是基于这些是测量的数据，暂定是正确的。      
(3) 数据的偏度全部大于0，说明数据全部右偏，部分特征值存在较大的影响值。 右偏前5：chlorides > volatile acidity > free sulfur dioxide > citric acid> residual sugar。pH和total sulfur dioxide偏度最小。    
(4) 除了酒精特征，其余特征都呈现尖峰分布。尖峰前5:chlorides > free sulfur dioxide > density > citric acid > volatile acidity。total sulfur dioxide和pH峰度较小。    
(5) qualty质量分有3-9分，主要集中于6 5 7这三个分数，占比分别为45%、30%、18%。评分很高的9分和很低的3分共计占比不足1%，主要中等这部分占比较高(93%)，所以找到关键因素，提高酒的品质，对酿酒人来说很重要。   
#### (2.2) 缺失值情况
```
print(wine_data.isnull().sum())
```
数据都是数值型数据，没有缺失值。  
![](https://ftp.bmp.ovh/imgs/2020/11/60ae5eb564bd390c.png)  
![](https://ftp.bmp.ovh/imgs/2020/12/615545519fe12927.png)
#### (2.3) 变量线性关系
```
corr = wine_data.corr()
mask = np.zeros_like(corr, dtype=np.bool)
mask[np.triu_indices_from(mask)] = True
sns.heatmap(corr, annot=True, mask=mask, linewidths=0.1, linecolor='white', vmin=-1, vmax=1)
plt.show()
```
![](https://ftp.bmp.ovh/imgs/2020/12/6164802974beabd0.png)   
从热力图看到：  
(1) 酒的品质跟酒精含量、密度的线性相关关系较强，酒精含量越高，口感评分越高。密度越高，口感评分越低。    
(2) 密度与剩余糖分的相关系数为0.84，与酒精的相关系数为-0.78。存在多重共线性。但是考虑到密度与酒精含量对口感评分的影响，先不删除任何特征。
### 三. 数据清洗&建模分析：
(3.1) 标准化处理：  
```
from sklearn.preprocessing import scale
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LassoCV
from sklearn.metrics import mean_squared_error

X = wine_data.iloc[:, 0:11]
Y = wine_data.loc[:, 'quality']
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.25, random_state=1000)
# print(X)
# print(Y)
x_train = scale(X_train)
x_test = scale(X_test)
model_1 = LassoCV(cv=10).fit(x_train, Y_train)
plt.plot()
plt.plot(model_1.alphas_, model_1.mse_path_, linestyle=':', label='均方误差')
plt.plot(model_1.alphas_, model_1.mse_path_.mean(axis=-1), label='十折均方误差均值', linewidth=2.5)
plt.axvline(model_1.alpha_, linestyle='-.', label='最佳α值')
plt.semilogx()
ax = plt.gca()
ax.invert_xaxis()
plt.title('十折交叉验证对应 MSE 表现')
plt.xlabel('α值')
plt.ylabel('均方误差MSE')
plt.show()
print('截距：', model_1.intercept_)
coef_Lasso = pd.DataFrame(model_1.coef_, index=col[0:11], columns=['回归系数'])
print('回归系数：\n', coef_Lasso.sort_values(by='回归系数', ascending=False))
print('惩罚系数alpha:', model_1.alpha_)
print('均方误差:', min(model_1.mse_path_.mean(axis=-1)))
y1_pred = model_1.predict(x_test)
print("均方误差：", mean_squared_error(Y_test, y1_pred))
```

(3.2) 
